# 第一章 - 内存的基本知识

## “按字节编址”和“按字编址”

按字节编址是将内存按照 Byte(8 bits) 划分为存储单元，从 0 开始按序编址。

其结果是不随计算机字长（16 位，32 位，64 位）的变化而变化的。

按字编址是将内存按照（计算机字长 * bits）划分为存储单元，从 0 开始按序编址。这种情况下，计算机是多少位，其一个地址就是多少个 bit。

## 如何计算一块内存所需的地址长度

将内存大小（如 4GB）折算为 2 的幂

4\*2^30 Bytes = 2^32 Bytes

若按字节编址，直接将其对 2 取对数即可。

## 指令的工作原理

每个进程在内存中占有两块：

- 程序段 - 存放指令
- 数据段 - 存放变量的值

CPU 从进程的程序段接收到编译后的机器码后，对其进行解析；

若为数据传送指令，CPU 从数据段取操作数的数值存入寄存器；

若为运算指令，CPU 从操作数中读取寄存器地址，从该寄存器中取值，再与其他操作数作相应运算；

或者，将寄存器中的变量写回到内存。

## 程序的运行原理

C 语言程序经过编译、链接处理后，形成装入模块（也即“可执行文件”，Windows 系统下为 .exe）。

该文件只声明逻辑地址，即以进程的起始地址为 0 号地址，顺序声明。

换言之，逻辑地址是一种“相对”地址。

## 装入方式与地址转换

### 绝对装入

适用条件：编译时，我就知道这个程序会被放入内存的哪个位置。

做法：我直接将相对地址加上进程的起始位置，作为绝对地址。

这个做法只适用于单道程序环境（即还没有操作系统的情况）。

### 可重定位装入

#### 静态重定位

编译、链接后装入模块的地址都从 0 开始。指令中使用的地址和数据存放的地址都是逻辑地址。根据内存的情况，决定装入模块装入到什么地址，然后将逻辑地址一次性全部变为物理地址。

静态重定位要求每个作业必须一次性拿到所有的内存空间，否则不能装入。作业一旦进入内存，运行期间就不能再移动，也不能再申请新的内存空间。

#### 动态重定位（动态运行时装入）

仍然和静态重定位一样，装入逻辑地址。

系统准备一个重定位寄存器，存放装入模块存放的起始地址。

CPU 会将逻辑地址加上地址得到物理地址。

这样程序就可以在内存中移动，且可以装入不连续的内存空间中，以及可以随时申请新的内存空间。

### 程序链接的三种方式

#### 静态链接

在程序运行前，将各目标模块及其所需库函数连接成一个完整的装入模块，不再拆开。

#### 装入时动态链接

各个目标模块不事先链接，装入内存时边装入边链接。

#### 运行时动态链接

需要某个模块的时候，才把这个模块装入内存，进行链接。

有便于修改更新和共享模块，以及节省内存空间的优点。
