# 第八讲-数值方法
## 借助quad()实现数值积分
`quad(表达式, 积分下限, 积分上限, 容许误差)`

`表达式` 不是一个符号变量。

可以完成`表达式`从积分下限到积分上限的数值积分。

`quadl(表达式, 积分下限, 积分上限, 容许误差)`

与 quad() 函数采用的数值积分方法不同，*可能精度更高*，

使用方法相同。

`容许误差` 是一个很小的数字，表示能够接受的误差范围。
### quad() 和 quadl() 对表达式的要求
表达式应是字符串或匿名函数，

且其中的运算应当使用**点运算**。
### 巧妙地选择数值积分上限
当利用数值方法计算积分上限是无穷大的积分时，

并非把积分限的绝对值取得越大越好，

反而有可能由于积分区域过大引入过多的数值误差，破坏精度。

以这个函数为例：

![J4B0fK.png](https://s1.ax1x.com/2020/04/28/J4B0fK.png)

从它的图像可以看到，这个函数在 25 之后的函数值都在 0 附近，

将这些部分积分进去没有很大意义。

拉长积分上限引入的误差会导致严重的精度损失。

更好的方法是将积分上限就选在 25 的附近，然后调低 `容许误差` 的数值。

## 数值差分
df(x)/dx ≈ (f(x+h) - f(x-h))/2h

称为中点差商，比起导数定义当中的那个式子（称为前向差商），

在 f(x) 可导的情况下，在同样的运算复杂度下误差是 h^2 的同阶无穷小 O(h^2)，

好于前向差商的 O(h)，故更加常用。
## 非线性方程（组）求解
### 解析方法：solve()
`solve(函数1, 函数2, 函数3, ..., 函数n, 自变量1, 自变量2, ..., 自变量n)`

求使得方程 `函数`=0 成立的 `自变量` 的解，或由上述 n 个函数组成的方程组的解。

这个是解析方法，`函数` 和 `自变量` 都是符号变量。

### fsolve()
`fsolve(表达式, 初始迭代点)`

表达式可以是字符串或匿名函数，

初始迭代点是估计解所在位置的附近某点。

则 fsolve() 返回**使得**`表达式`**为 0**的 `自变量`的数值。

可以用一个行向量 [初始迭代点1, 初始迭代点2, 初始迭代点3，...]

这样会返回多个根。

在这种情况下，`表达式` 中**必须使用点运算**。

`表达式` 可以有多个，
### fzero()
`fzero(表达式, [区间左端点, 区间右端点])`

求解表达式在 [区间左端点, 区间右端点] 区间上的**一个**零点。

即使区间上有多个零点，fzero() 也只返回一个。

这个函数只能求解一个方程，不能求解方程组。
